// package fringe

// import chisel3._
// import chisel3.util._

// /**
//  * Accel: Sample top module generated by Chisel used for Fringe testing
//  * @param w: Word width
//  * @param numArgIns: Number of input scalar arguments
//  * @param numArgOuts: Number of output scalar arguments
//  */
// class Accel(val w: Int, val numArgIns: Int, val numArgOuts: Int, val numMemoryStreams: Int = 1) extends Module {
//   val v = 16
//   val io = IO(new Bundle {
//     // Control
//     val enable = Input(Bool())
//     val done = Output(Bool())

//     // Scalars
//     val argIns = Input(Vec(numArgIns, UInt(w.W)))
//     val argOuts = Vec(numArgOuts, Decoupled((UInt(w.W))))

//     // Tile Load
//     val memStreams = Vec(numMemoryStreams, Flipped(new MemoryStream(w, v)))
//   })

//   // This temporary module assumes that numArgIns = numArgOuts
//   Predef.assert(numArgIns == numArgOuts, s"This Accel module assumes equal number of argIns and argOuts")

//   // Add 1 to all argIns, write to argOuts
//   io.argIns.zip(io.argOuts) foreach { case (in, out) =>
//     out.bits := in + UInt(1)
//   }

//   // Output is 'done' one cycle later
//   val counter = Module(new Counter(w))
//   counter.io.max := UInt(10)
//   counter.io.stride := UInt(1)
//   counter.io.enable := io.enable
//   io.done := counter.io.done

//   val pulser = Module(new Pulser())
//   pulser.io.in := io.enable
// //  io.done := pulser.io.out

//   // Assign 'valid's to all argOuts
//   io.argOuts.map { _.valid }.foreach { v => v := pulser.io.out }

//   // Send a simple read command (tileload)
//   io.memStreams(0).cmd.bits.addr(0) := io.argIns(0)  // First argIn is addr
//   io.memStreams(0).cmd.bits.size := io.argIns(1)  // Second argIn is size in bytes
//   io.memStreams(0).cmd.bits.isWr := UInt(0)
//   io.memStreams(0).cmd.valid := Reg(UInt(1.W), pulser.io.out)

//   // Send a store
//   io.memStreams(1).cmd.bits.addr(0) := io.argIns(2)  // First argIn is addr
//   io.memStreams(1).cmd.bits.size := io.argIns(3)  // Second argIn is size in bytes
//   io.memStreams(1).cmd.bits.isWr := UInt(1)
//   io.memStreams(1).cmd.valid := pulser.io.out
//   io.memStreams(1).wdata.bits := Vec(List.tabulate(v) { i => counter.io.out * UInt(i+1) })
//   io.memStreams(1).wdata.valid := io.enable

//   val rdata = Wire(Vec(v, UInt(w.W)))
//   rdata := io.memStreams(0).rdata.bits
// }
